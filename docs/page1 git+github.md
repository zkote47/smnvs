# Git + GitHub

https://www.youtube.com/watch?v=VJm_AjiTEEc
https://www.youtube.com/watch?v=F7FnnfnB9YY&t=978s

**Соединение с GitHub.**

`git config –global user.name “имя с гитхаба”`
`git config –global user.email “почта с гитхаба”`

# **Основная работа.**

Превратим папку в локальный гит-репозиторий:
`cd <путь к папке>` - перейти в папку, которую хотим сделать локальным репозиторием.
`git init` – сделать данную папку репозиторием.

Не забываем добавить в корневую папку файл `.gitignore.`
Дописываем в нём:
venv/
.idea/

На данном этапе или ранее нужно создать в GitHub пустой удаленный репозиторий, который в дальнейшем свяжем с нашим локальным репозиторием.

`git remote add origin <url репозитория с GitHub>`- соединяет локальный репозиторий с удаленным по url. Можно скопировать с пока еще пустого удаленного репозитория в GitHub. Желательно пока не добавлять по умолчанию **гитигнор** , а загрузить его с остальными файлами из локального репозитория. Иначе придётся танцевать с бубном через команду:

`git pull origin main --allow-unrelated-histories` - объединение удалённого и локального.

`git add <через пробел имена файлов с расширениями>` – подготавливает данные файлы к следующему коммиту, добавляя их в «индекс» гита.

«Индекс» гита – это хранилище файлов, готовых к коммиту. Прежде чем сделать _commit_ необходимо указать имена папок/файлов в виде отдельной версии, готовых к сохранению.

`git add .` – добавить в отслеживаемые все файлы в текущей директории.

`git status` – убедимся, что в отслеживаемое не попало лишнее и гитигнор сработал.

%% (use "git rm --cached {file..."} to unstage) %%

`git commit -m message` – запоминает версию (_коммит_) всех файлов в репозитории из индекса и присваивает ей уникальный код (хэш), по которому затем к этой версии можно вернуться. В сообщении в т.ч. на русском кратко отражают изменения.

`git branch -M main` – переименовываем главную ветку в **main**. Опционально.

`git push <имя-репозитория> <ветка>` - публикует коммиты из локального репозитория в удаленный с данным именем в данной его ветке.

_Прочее:_

`git status` – показывает текущий статус всех несохраненных (uncommited) изменений файлов в репозитории.

`git log` – показывает историю всех коммитов в данной ветке с их хэшами и сообщениями в хронологическом порядке.

`git chekout <хэш>` - возвращение к версии.

# Исправление ошибки в последнем коммите.

Если вы хотите изменить только сообщение вашего последнего коммита, это очень просто:

`git commit --amend`

Эта команда откроет в вашем текстовом редакторе сообщение вашего последнего коммита для того, чтобы вы могли его исправить. Когда вы сохраните его и закроете редактор, будет создан новый коммит, содержащий это сообщение, который теперь и будет вашим последним коммитом.

Если вы создали коммит и затем хотите изменить зафиксированный снимок, добавив или изменив файлы (возможно, вы забыли добавить вновь созданный файл, когда совершали изначальный коммит), то процесс выглядит в основном так же. Вы добавляете в индекс необходимые изменения, редактируя файл и выполняя для него git add или git rm для отслеживаемого файла, а последующая команда git commit --amend берёт вашу текущую область подготовленных изменений и делает её снимок для нового коммита.

Команда `git restore --staged <file>` используется для того, чтобы убрать файл из индекса **Git** (то есть отменить добавление файла в индекс). Это означает, что изменения, внесённые в этот файл, перестанут отслеживаться системой контроля версий до следующей команды **git add**.

Эта команда эквивалентна команде:

`git reset HEAD <file>`

Таким образом, после выполнения этой команды файл останется в рабочем дереве, но все изменения в нём будут считаться неотслеживаемыми (unstaged), то есть они не попадут в следующий коммит, пока вы снова не выполните команду git add.

# Работа в команде.

Чтобы другому участнику команды скачать актуальные коммиты из удалённого репозитория нужно перейти в нужный локальный репозиторий и выполнить следующую команду:

git clone url-удаленного-репозитория> - используется для клонирования (копирования) удаленного репозитория на компьютер. Она создает новый локальный репозиторий, который является полной копией удаленного репозитория. Данный репозиторий уже автоматически связан с удалённым репозиторием.

`git pull <remote> <branch>` - используется для обновления вашего локального репозитория до последней версии, которая находится на удаленном сервере. Эта команда объединяет все изменения, сделанные другими разработчиками, с вашей локальной копией.

- `<remote>` – имя удалённого репозитория (например, origin, если вы клонировали проект с GitHub).

- `<branch>` – ветка, которую вы хотите обновить (если не указана, будет использована текущая ветка).


Как работает git pull?

Когда вы выполняете команду git pull, происходит следующее:

1. Фетчинг (fetch) – скачивание всех новых данных с указанного удалённого репозитория.
2. Мержинг (merge) – объединение этих данных с вашей текущей рабочей копией.

Таким образом, `git pull` выполняет две команды одновременно: сначала `git fetch`, а затем `git merge`.


# Ветки.

**Ветка** – последовательность коммитов, имеющая своё имя. Основную чаще называют master или main.

`git branch` – выводит список локальных веток, доступных прямо сейчас в данном локальном репозитории.

`*` - ветка, на которой мы находимся в данный момент.

Создать новую ветку от основной:
`git branch <НОВАЯ ветка>`

`git checkout <имя ветки>` - переключает пользователя на данную локальную ветку. Все новые коммиты после этого будут делаться именно в этой ветке.

Чтобы запушить на GitHub новую локальную ветку, нужно перейти в локальной репозиторий новой ветки (важно в этот момент быть переключенным на новую ветку с помощью команды выше), использовать опять же команду:

`git push <имя_репозитория> <НОВАЯ ветка>`

(предварительно прогнав git add, git commit, cм. выше)

## Слияние веток

Когда новая ветка полностью протестирована, производят слияние этой ветки с основной. Есть два механизма слияния.

1.

`git merge <имя ветки>` - производит слияние этой ветки в ветку, на которой прямо сейчас находится пользователь в виде одного нового коммита в текущую ветку. То есть берёт ВСЁ, что было в ветке и передает на основную ветку в виде **одного коммита.**

Всё это происходит в нашем локальном репозитории. Чтобы опубликовать результат необходимо опять же выполнить push мастера в удаленный репозиторий.

2.

`git rebase <имя ветки>` - перемещает коммиты из данной ветки в ту, на которой сейчас находится пользователь.

То есть переходим в директорию КУДА нужно совершить перемещение, а потом прописываем имя ветки в этой команде, ИЗ КОТОРОЙ нужно переместить данные.

Ключевое отличие этого подхода заключается в том, что перемещение в главную ветку идет в виде **каждого отдельного коммита**, а не одного. Данный метод используется если нужна вся история изменений в данной ветке.

## Cherry pick.

Для того чтобы выполнить cherry pick необходимо сначала перейти в ту ветку, в которую необходимо перенести коммит (git checkout).

`git cherry-pick <хэш>`

Хэш можно взять из истории (git log). Хэш можно копировать не полностью, а хотя бы 7 символов.

## Возвращение к прошлым версиям

Чтобы отменить изменения последнего коммита и откатиться на коммит, стоящий перед ним, необходимо ввести команду:

`git revert <хэш>`

После чего в ветке после «отменённого» коммита образуется новый (имеет свой хэш). То есть коммит с «нежелательными» изменениями останется звеном в цепочки цепи и к нему можно будет вернуться. Отмена какого-либо коммита это новый коммит с откатом изменений.

Чтобы удалить изменения, не оставляя их в истории ветки, обратимся к другому методу.

`git reset --soft <хэш>` удаляет коммиты из ветки до указанного коммита (невключительно), но те изменения, что были в этих коммитах не стираются, а сохраняются в индекс гита, то есть как несохраненные изменения.

`git reset --hard <хэш>` удаляет изменения полностью и отменяет коммиты.